// Code generated by protoc-gen-go.
// source: vinna.proto
// DO NOT EDIT!

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	vinna.proto

It has these top-level messages:
	Topic
	TopicCreated
	Message
	Success
	MessageRequest
	ProducerSummary
	ConsumeRequest
*/
package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Topic struct {
	Topic string `protobuf:"bytes,1,opt,name=topic" json:"topic,omitempty"`
}

func (m *Topic) Reset()                    { *m = Topic{} }
func (m *Topic) String() string            { return proto.CompactTextString(m) }
func (*Topic) ProtoMessage()               {}
func (*Topic) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Topic) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

type TopicCreated struct {
	Success bool `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
}

func (m *TopicCreated) Reset()                    { *m = TopicCreated{} }
func (m *TopicCreated) String() string            { return proto.CompactTextString(m) }
func (*TopicCreated) ProtoMessage()               {}
func (*TopicCreated) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *TopicCreated) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type Message struct {
	Uuid  string `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	Topic string `protobuf:"bytes,2,opt,name=topic" json:"topic,omitempty"`
	Msg   []byte `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Message) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *Message) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *Message) GetMsg() []byte {
	if m != nil {
		return m.Msg
	}
	return nil
}

type Success struct {
	MsgID   string `protobuf:"bytes,1,opt,name=msgID" json:"msgID,omitempty"`
	Success bool   `protobuf:"varint,2,opt,name=success" json:"success,omitempty"`
}

func (m *Success) Reset()                    { *m = Success{} }
func (m *Success) String() string            { return proto.CompactTextString(m) }
func (*Success) ProtoMessage()               {}
func (*Success) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Success) GetMsgID() string {
	if m != nil {
		return m.MsgID
	}
	return ""
}

func (m *Success) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type MessageRequest struct {
	Topic string `protobuf:"bytes,1,opt,name=topic" json:"topic,omitempty"`
	MsgID string `protobuf:"bytes,2,opt,name=msgID" json:"msgID,omitempty"`
}

func (m *MessageRequest) Reset()                    { *m = MessageRequest{} }
func (m *MessageRequest) String() string            { return proto.CompactTextString(m) }
func (*MessageRequest) ProtoMessage()               {}
func (*MessageRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *MessageRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *MessageRequest) GetMsgID() string {
	if m != nil {
		return m.MsgID
	}
	return ""
}

type ProducerSummary struct {
	MsgCount    int32 `protobuf:"varint,1,opt,name=msgCount" json:"msgCount,omitempty"`
	TopicCount  int32 `protobuf:"varint,2,opt,name=topicCount" json:"topicCount,omitempty"`
	ElapsedTime int32 `protobuf:"varint,3,opt,name=elapsedTime" json:"elapsedTime,omitempty"`
}

func (m *ProducerSummary) Reset()                    { *m = ProducerSummary{} }
func (m *ProducerSummary) String() string            { return proto.CompactTextString(m) }
func (*ProducerSummary) ProtoMessage()               {}
func (*ProducerSummary) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ProducerSummary) GetMsgCount() int32 {
	if m != nil {
		return m.MsgCount
	}
	return 0
}

func (m *ProducerSummary) GetTopicCount() int32 {
	if m != nil {
		return m.TopicCount
	}
	return 0
}

func (m *ProducerSummary) GetElapsedTime() int32 {
	if m != nil {
		return m.ElapsedTime
	}
	return 0
}

type ConsumeRequest struct {
	Topic string `protobuf:"bytes,1,opt,name=topic" json:"topic,omitempty"`
}

func (m *ConsumeRequest) Reset()                    { *m = ConsumeRequest{} }
func (m *ConsumeRequest) String() string            { return proto.CompactTextString(m) }
func (*ConsumeRequest) ProtoMessage()               {}
func (*ConsumeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ConsumeRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func init() {
	proto.RegisterType((*Topic)(nil), "pb.Topic")
	proto.RegisterType((*TopicCreated)(nil), "pb.TopicCreated")
	proto.RegisterType((*Message)(nil), "pb.Message")
	proto.RegisterType((*Success)(nil), "pb.Success")
	proto.RegisterType((*MessageRequest)(nil), "pb.MessageRequest")
	proto.RegisterType((*ProducerSummary)(nil), "pb.ProducerSummary")
	proto.RegisterType((*ConsumeRequest)(nil), "pb.ConsumeRequest")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Vinna service

type VinnaClient interface {
	// NewTopic will create a new topic for messages
	NewTopic(ctx context.Context, in *Topic, opts ...grpc.CallOption) (*TopicCreated, error)
	// Add a message to vinna
	Add(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Success, error)
	// Take a message from vinna
	Take(ctx context.Context, in *MessageRequest, opts ...grpc.CallOption) (*Message, error)
	// Produce will open up a production stream of data
	Produce(ctx context.Context, opts ...grpc.CallOption) (Vinna_ProduceClient, error)
	// Consumer will be an endpoint for streaming data to a client side consumer
	Consume(ctx context.Context, in *ConsumeRequest, opts ...grpc.CallOption) (Vinna_ConsumeClient, error)
}

type vinnaClient struct {
	cc *grpc.ClientConn
}

func NewVinnaClient(cc *grpc.ClientConn) VinnaClient {
	return &vinnaClient{cc}
}

func (c *vinnaClient) NewTopic(ctx context.Context, in *Topic, opts ...grpc.CallOption) (*TopicCreated, error) {
	out := new(TopicCreated)
	err := grpc.Invoke(ctx, "/pb.Vinna/NewTopic", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vinnaClient) Add(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Success, error) {
	out := new(Success)
	err := grpc.Invoke(ctx, "/pb.Vinna/Add", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vinnaClient) Take(ctx context.Context, in *MessageRequest, opts ...grpc.CallOption) (*Message, error) {
	out := new(Message)
	err := grpc.Invoke(ctx, "/pb.Vinna/Take", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vinnaClient) Produce(ctx context.Context, opts ...grpc.CallOption) (Vinna_ProduceClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Vinna_serviceDesc.Streams[0], c.cc, "/pb.Vinna/Produce", opts...)
	if err != nil {
		return nil, err
	}
	x := &vinnaProduceClient{stream}
	return x, nil
}

type Vinna_ProduceClient interface {
	Send(*Message) error
	CloseAndRecv() (*ProducerSummary, error)
	grpc.ClientStream
}

type vinnaProduceClient struct {
	grpc.ClientStream
}

func (x *vinnaProduceClient) Send(m *Message) error {
	return x.ClientStream.SendMsg(m)
}

func (x *vinnaProduceClient) CloseAndRecv() (*ProducerSummary, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ProducerSummary)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vinnaClient) Consume(ctx context.Context, in *ConsumeRequest, opts ...grpc.CallOption) (Vinna_ConsumeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Vinna_serviceDesc.Streams[1], c.cc, "/pb.Vinna/Consume", opts...)
	if err != nil {
		return nil, err
	}
	x := &vinnaConsumeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Vinna_ConsumeClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type vinnaConsumeClient struct {
	grpc.ClientStream
}

func (x *vinnaConsumeClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Vinna service

type VinnaServer interface {
	// NewTopic will create a new topic for messages
	NewTopic(context.Context, *Topic) (*TopicCreated, error)
	// Add a message to vinna
	Add(context.Context, *Message) (*Success, error)
	// Take a message from vinna
	Take(context.Context, *MessageRequest) (*Message, error)
	// Produce will open up a production stream of data
	Produce(Vinna_ProduceServer) error
	// Consumer will be an endpoint for streaming data to a client side consumer
	Consume(*ConsumeRequest, Vinna_ConsumeServer) error
}

func RegisterVinnaServer(s *grpc.Server, srv VinnaServer) {
	s.RegisterService(&_Vinna_serviceDesc, srv)
}

func _Vinna_NewTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Topic)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VinnaServer).NewTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Vinna/NewTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VinnaServer).NewTopic(ctx, req.(*Topic))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vinna_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VinnaServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Vinna/Add",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VinnaServer).Add(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vinna_Take_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VinnaServer).Take(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Vinna/Take",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VinnaServer).Take(ctx, req.(*MessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vinna_Produce_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(VinnaServer).Produce(&vinnaProduceServer{stream})
}

type Vinna_ProduceServer interface {
	SendAndClose(*ProducerSummary) error
	Recv() (*Message, error)
	grpc.ServerStream
}

type vinnaProduceServer struct {
	grpc.ServerStream
}

func (x *vinnaProduceServer) SendAndClose(m *ProducerSummary) error {
	return x.ServerStream.SendMsg(m)
}

func (x *vinnaProduceServer) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Vinna_Consume_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ConsumeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VinnaServer).Consume(m, &vinnaConsumeServer{stream})
}

type Vinna_ConsumeServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type vinnaConsumeServer struct {
	grpc.ServerStream
}

func (x *vinnaConsumeServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

var _Vinna_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Vinna",
	HandlerType: (*VinnaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NewTopic",
			Handler:    _Vinna_NewTopic_Handler,
		},
		{
			MethodName: "Add",
			Handler:    _Vinna_Add_Handler,
		},
		{
			MethodName: "Take",
			Handler:    _Vinna_Take_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Produce",
			Handler:       _Vinna_Produce_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Consume",
			Handler:       _Vinna_Consume_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "vinna.proto",
}

func init() { proto.RegisterFile("vinna.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 352 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x7c, 0x92, 0xc1, 0x4b, 0xc3, 0x30,
	0x14, 0xc6, 0xdb, 0x6e, 0xb5, 0xdb, 0xdb, 0x98, 0xe3, 0xe9, 0x61, 0x14, 0x94, 0x99, 0x83, 0x74,
	0x97, 0x2a, 0x7a, 0x12, 0xbc, 0xc8, 0xf4, 0xe0, 0x41, 0x91, 0x6e, 0x78, 0xef, 0xda, 0x50, 0x8a,
	0xa6, 0xa9, 0x4d, 0xa3, 0xf8, 0xe7, 0xfa, 0x9f, 0x48, 0xd3, 0x6c, 0xcb, 0x86, 0x78, 0xfb, 0xbe,
	0xbc, 0xe4, 0xc7, 0xf7, 0xde, 0x0b, 0x0c, 0x3e, 0xf3, 0xa2, 0x88, 0xc3, 0xb2, 0xe2, 0x35, 0x47,
	0xa7, 0x5c, 0x91, 0x13, 0x70, 0x97, 0xbc, 0xcc, 0x13, 0x3c, 0x06, 0xb7, 0x6e, 0xc4, 0xc4, 0x9e,
	0xda, 0x41, 0x3f, 0x6a, 0x0d, 0x09, 0x60, 0xa8, 0xca, 0xf3, 0x8a, 0xc6, 0x35, 0x4d, 0x71, 0x02,
	0x9e, 0x90, 0x49, 0x42, 0x85, 0x50, 0xf7, 0x7a, 0xd1, 0xda, 0x92, 0x07, 0xf0, 0x9e, 0xa8, 0x10,
	0x71, 0x46, 0x11, 0xa1, 0x2b, 0x65, 0x9e, 0x6a, 0x92, 0xd2, 0x5b, 0xbc, 0x63, 0xe0, 0x71, 0x0c,
	0x1d, 0x26, 0xb2, 0x49, 0x67, 0x6a, 0x07, 0xc3, 0xa8, 0x91, 0xe4, 0x06, 0xbc, 0x45, 0x4b, 0x6c,
	0x9e, 0x30, 0x91, 0x3d, 0xde, 0xaf, 0x13, 0x29, 0x63, 0x26, 0x70, 0x76, 0x13, 0xdc, 0xc2, 0x48,
	0x27, 0x88, 0xe8, 0x87, 0xa4, 0xa2, 0xfe, 0xbb, 0xa7, 0x2d, 0xd7, 0x31, 0xb8, 0x84, 0xc3, 0xe1,
	0x4b, 0xc5, 0x53, 0x99, 0xd0, 0x6a, 0x21, 0x19, 0x8b, 0xab, 0x6f, 0xf4, 0xa1, 0xc7, 0x44, 0x36,
	0xe7, 0xb2, 0xa8, 0x15, 0xc1, 0x8d, 0x36, 0x1e, 0x4f, 0x01, 0x14, 0xad, 0xad, 0x3a, 0xaa, 0x6a,
	0x9c, 0xe0, 0x14, 0x06, 0xf4, 0x3d, 0x2e, 0x05, 0x4d, 0x97, 0x39, 0xa3, 0xaa, 0x43, 0x37, 0x32,
	0x8f, 0xc8, 0x39, 0x8c, 0xe6, 0xbc, 0x10, 0x92, 0xfd, 0x1f, 0xf7, 0xea, 0xc7, 0x06, 0xf7, 0xb5,
	0xd9, 0x1a, 0xce, 0xa0, 0xf7, 0x4c, 0xbf, 0xda, 0x75, 0xf5, 0xc3, 0x72, 0x15, 0x2a, 0xe9, 0x8f,
	0x37, 0x52, 0x6f, 0x89, 0x58, 0x78, 0x06, 0x9d, 0xbb, 0x34, 0xc5, 0x41, 0x53, 0xd2, 0x43, 0xf1,
	0x95, 0xd1, 0xc3, 0x25, 0x16, 0xce, 0xa0, 0xbb, 0x8c, 0xdf, 0x28, 0xa2, 0x71, 0x47, 0x27, 0xf1,
	0xcd, 0x77, 0xc4, 0xc2, 0x0b, 0xf0, 0xf4, 0x6c, 0x76, 0x89, 0x47, 0x8d, 0xd9, 0x9b, 0x1a, 0xb1,
	0x02, 0x1b, 0x43, 0xf0, 0x74, 0x6f, 0x2d, 0x7e, 0xb7, 0xd1, 0x3d, 0xfc, 0xa5, 0xbd, 0x3a, 0x50,
	0x1f, 0xf2, 0xfa, 0x37, 0x00, 0x00, 0xff, 0xff, 0x74, 0xb0, 0x0a, 0x75, 0x9f, 0x02, 0x00, 0x00,
}
